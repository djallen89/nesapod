use time;
use std::collections::VecDeque;
use std::fs::{File, OpenOptions};
use std::io::Error as IOError;
use std::io::prelude::*;
use std::path::PathBuf;

/// Debug is meant to output text to a text buffer and a file, printing
/// messages generated by errors and to quantify other metrics for analysis.
pub struct Debug {
    length: u8,
    logname: Option<PathBuf>,
    messages: VecDeque<String>,
}

pub fn default_log(logging: bool) -> Option<PathBuf> {
    if logging {
        let t = time::now();
        let ts = match time::strftime("%y%m%d%H%M%S", &t) {
            Ok(s) => s,
            Err(f) => panic!(f)
        };
        let p = PathBuf::from(&format!("logs/{}.log", ts));
        match File::create(&p) {
            Ok(_) => {},
            Err(f) => panic!(f)
        }
        Some(p)
    } else {
        None
    }
}

impl Debug {
    pub fn new(cap: u8, logging: bool) -> Debug {
        Debug {
            length: cap, 
            logname: default_log(logging),
            messages: VecDeque::with_capacity(cap as usize)
        }
    }

    pub fn output(&self) -> String {
        let mut out = String::new();
        for msg in self.messages.iter().rev() {
            out.push_str(msg);
        }
        out
    }

    pub fn input(&mut self, msg: &str) {
        while self.messages.len() >= self.length as usize {
            let back = self.messages.pop_back().unwrap();
            match self.write(&back) {
                Ok(_) => {},
                Err(f) => panic!(f)
            };
        }
        self.messages.push_front(format!("{}", msg));
    }

    pub fn input_ln(&mut self, msg: &str) {
        while self.messages.len() >= self.length as usize {
            let back = self.messages.pop_back().unwrap();
            match self.write(&back) {
                Ok(_) => {},
                Err(f) => panic!(f)
            };
        }
        self.messages.push_front(format!("{}\n", msg));
    }

    pub fn write(&mut self, msg: &str) -> Result<(), IOError> {
        if let Some(ref path) = self.logname {
            match OpenOptions::new().append(true).open(path) {
                Ok(mut f) => {
                    f.write_all(msg.as_bytes())?;
                    f.sync_data()?;
                    Ok(())
                },
                Err(e) => return Err(e)
            }
        } else {
            Ok(())
        }
    }

    pub fn flush(&mut self) -> Result<(), IOError> {
        if let Some(ref path) = self.logname {
            match OpenOptions::new().append(true).open(path) {
                Ok(mut f) => {
                    for msg in self.messages.drain(..).rev() {
                        f.write_all(msg.as_bytes())?;
                    }
                    f.sync_all()?;
                    Ok(())
                },
                Err(f) => Err(f)
            }
        } else {
            Ok(())
        }
    }
}
