use std::collections::VecDeque;
use std::fs::File;
use std::io::Error as IOError;
use std::io::prelude::*;

/// Debug is meant to output text to a text buffer and a file, printing
/// messages generated by errors and to quantify other metrics for analysis.
pub struct Debug<'g> {
    length: u8,
    file: Option<&'g File>,
    messages: VecDeque<String>,
}

impl<'g> Debug<'g> {
    pub fn new(cap: u8, f: Option<&'g File>) -> Debug {
        Debug {
            length: cap,
            file: f,
            messages: VecDeque::with_capacity(cap as usize)
        }
    }

    pub fn output(&self) -> String {
        let mut out = String::new();
        for msg in self.messages.iter().rev() {
            out.push_str(msg);
            out.push_str("\n");
        }
        out
    }

    pub fn input(&mut self, msg: &str) -> Result<(), ()> {
        while self.messages.len() >= self.length as usize {
            let back = self.messages.pop_back().unwrap();
            match self.write(&back) {
                Ok(_) => {},
                Err(_) => {}
            };
        }
        self.messages.push_front(msg.to_string());
        Ok(())
    }

    pub fn write(&mut self, msg: &str) -> Result<(), IOError> {
        match self.file {
            None => {
                Ok(())
            },
            Some(ref mut log) => {
                log.write_all(msg.as_bytes())?;
                Ok(())
            }
        }
    }

    pub fn flush(&mut self) -> Result<(), IOError> {
        if self.file.is_none() {
            return Ok(())
        }

        for msg in self.messages.drain(..).rev() {
            self.file.unwrap().write_all(msg.as_bytes())?;
        }

        self.file.unwrap().sync_all()?;
        Ok(())
    }
}
